#![no_std]
#![no_main]


// Simple 8x8 bitmap font data
const FONT_DATA: [[u8; 8]; 128] = [
    // 0x00-0x1F: Control characters (all zeros)
    [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8],
    [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8],
    [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8],
    [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8],
    
    // 0x20: Space
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // 0x21: !
    [0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],
    // 0x22: "
    [0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00],
    // 0x23: #
    [0x66, 0x66, 0xFF, 0x66, 0xFF, 0x66, 0x66, 0x00],
    // 0x24: $
    [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00],
    // 0x25: %
    [0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00],
    // 0x26: &
    [0x3C, 0x66, 0x3C, 0x38, 0x67, 0x66, 0x3F, 0x00],
    // 0x27: '
    [0x06, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
    // 0x28: (
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00],
    // 0x29: )
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00],
    // 0x2A: *
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
    // 0x2B: +
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
    // 0x2C: ,
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00],
    // 0x2D: -
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
    // 0x2E: .
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
    // 0x2F: /
    [0x00, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00],
    
    // 0x30-0x39: Numbers 0-9
    [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00], // 0
    [0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00], // 1
    [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00], // 2
    [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00], // 3
    [0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00], // 4
    [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00], // 5
    [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00], // 6
    [0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00], // 7
    [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00], // 8
    [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00], // 9
    
    // 0x3A-0x40: More symbols
    [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00], // :
    [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x30, 0x00], // ;
    [0x0E, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0E, 0x00], // <
    [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00], // =
    [0x70, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x70, 0x00], // >
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00], // ?
    [0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00], // @
    
    // 0x41-0x5A: Uppercase A-Z
    [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // A
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00], // B
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00], // C
    [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00], // D
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00], // E
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00], // F
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00], // G
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // H
    [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // I
    [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00], // J
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00], // K
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00], // L
    [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00], // M
    [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00], // N
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // O
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00], // P
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00], // Q
    [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00], // R
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00], // S
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // T
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // U
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // V
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // W
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00], // X
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00], // Y
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00], // Z
    
    // Fill remaining entries with zeros for simplicity
    [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], // 0x5B-0x60
    
    // 0x61-0x7A: Lowercase a-z (simplified - same as uppercase for now)
    [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // a
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00], // b
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00], // c
    [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00], // d
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00], // e
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00], // f
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00], // g
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // h
    [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // i
    [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00], // j
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00], // k
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00], // l
    [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00], // m
    [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00], // n
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // o
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00], // p
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00], // q
    [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00], // r
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00], // s
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // t
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // u
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // v
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // w
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00], // x
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00], // y
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00], // z
    
    // Fill remaining with zeros
    [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], [0x00; 8], // 0x7B-0x7F
];

// Text rendering functions
unsafe fn draw_char(fb_addr: *mut u32, width: u32, x: u32, y: u32, ch: u8, color: u32) {
    if (ch as usize) >= FONT_DATA.len() {
        return;
    }
    
    let font_data = &FONT_DATA[ch as usize];
    
    for row in 0..8 {
        let byte = font_data[row];
        for col in 0..8 {
            if (byte >> (7 - col)) & 1 != 0 {
                let px = x + col;
                let py = y + row as u32;
                if px < width && py < 2048 {
                    let pixel_offset = (py * width + px) as isize;
                    *fb_addr.offset(pixel_offset) = color;
                }
            }
        }
    }
}

unsafe fn draw_string(fb_addr: *mut u32, width: u32, x: u32, y: u32, s: &str, color: u32) {
    let mut current_x = x;
    for byte in s.bytes() {
        draw_char(fb_addr, width, current_x, y, byte, color);
        current_x += 8; // Move to next character position
        if current_x >= width - 8 {
            break; // Don't draw beyond screen
        }
    }
}

unsafe fn draw_u64(fb_addr: *mut u32, width: u32, x: u32, y: u32, number: u64, color: u32) {
    let mut current_x = x;
    draw_char(fb_addr, width, current_x, y, b'0', color);
    current_x += 8;
    draw_char(fb_addr, width, current_x, y, b'x', color);
    current_x += 8;
    for i in 0..16 {
        let nibble = (number >> ((15 - i) * 4)) & 0xf;
        let nibble = nibble as u8;
        let ch = match nibble {
           0..=9 => (b'0' + nibble),     // For 0-9, convert directly from ASCII '0'
           10..=15 => (b'a' + (nibble - 10)), // For 10-15, convert to 'a'-'f'
        _ => unreachable!(), // This case should never be reached with a valid nibble
        };
        draw_char(fb_addr, width, current_x, y, ch, color);
        current_x += 8;
    }
}


unsafe fn draw_number(fb_addr: *mut u32, width: u32, x: u32, y: u32, mut num: u32, color: u32) {
    if num == 0 {
        draw_char(fb_addr, width, x, y, b'0', color);
        return;
    }
    
    // Count digits
    let mut temp = num;
    let mut digit_count = 0;
    while temp > 0 {
        temp /= 10;
        digit_count += 1;
    }
    
    // Draw digits from right to left
    let mut current_x = x + (digit_count - 1) * 8;
    while num > 0 {
        let digit = (num % 10) as u8 + b'0';
        draw_char(fb_addr, width, current_x, y, digit, color);
        num /= 10;
        current_x = current_x.saturating_sub(8);
    }
}

const PAGE_PRESENT: u64 = 1 << 0;
const PAGE_WRITABLE: u64 = 1 << 1;
const PAGE_HUGE: u64 = 1 << 7;

#[repr(C)]
#[derive(Debug, Clone)]
pub struct BootInfo {
    pub memory_map: MemoryMapInfo,
    pub framebuffer: FramebufferInfo,
    pub rsdp_addr: Option<u64>,
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct MemoryMapInfo {
    pub entries: *const u8, // just opaque for now rather than MemoryDescriptor,
    pub entry_count: usize,
    pub entry_size: usize,
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct FramebufferInfo {
    pub addr: u64,
    pub width: u32,
    pub height: u32,
    pub pitch: u32,
    pub bpp: u32,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
}

#[no_mangle]
pub extern "C" fn _start(boot_info: *const BootInfo) -> ! {

    unsafe {
        let fb_addr = 0x80000000 as *mut u32;
        let width = 2048u32;
        let height = 2048u32;
        
        let mut counter = 0u32;
        
        loop {
            // Clear screen with black
            for i in 0..(width * 100) {
                *fb_addr.offset(i as isize) = 0xFF000000; // Black background
            }
            
            // Draw some text
            draw_string(fb_addr, width, 10, 10, "RustOS Kernel Running!", 0xFFFFFFFF); // White text
            draw_string(fb_addr, width, 10, 30, "Bootloader Success!", 0xFF00FF00); // Green text
            draw_string(fb_addr, width, 10, 50, "Counter: ", 0xFF00FFFF); // Cyan text
            draw_number(fb_addr, width, 90, 50, counter, 0xFF00FFFF); // Cyan number


            // Draw some dynamic info
            draw_string(fb_addr, width, 10, 70, "Fb addr:", 0xFFFF00FF); // Magenta
            draw_u64(fb_addr, width, 10 + 128, 70, (*boot_info).framebuffer.addr , 0xFFFF00FF); // Magenta
            draw_string(fb_addr, width, 10, 90, "Resolution: 2048x2048", 0xFFFFFF00); // Yellow
            
            counter += 1;
            
            // Delay
            for _ in 0..10000000 {
                core::arch::asm!("nop");
            }
        }
    }
}

#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    unsafe {
        let fb_addr = 0x80000000 as *mut u32;
        // Clear screen with red
        for i in 0..2048*2048 {
            *fb_addr.offset(i) = 0xFFFF0000;
        }
        // Draw "PANIC!" text
        draw_string(fb_addr, 2048, 50, 50, "PANIC!", 0xFFFFFFFF);
    }
    loop {}
}
